#version 430

#define D 21
#define r (D / 2)
#define R (r + 1)
#define WG 32

layout(local_size_x = WG, local_size_y = WG) in;

layout (std430, binding = 0) readonly buffer Kernel
{
    float kernelCoefs[];
};

layout (binding = 1, rgba8) uniform readonly image2D inImg;
layout (binding = 2, rgba8) uniform writeonly image2D outImg;

float kernel(int i)
{
    return kernelCoefs[abs(i)];
}

shared vec3 locImg[r + WG + r][r + WG + r];

void loadToLoc(ivec2 xy, ivec2 XY, ivec2 HW)
{
    locImg[r + xy.y][r + xy.x] = imageLoad(inImg, XY).xyz;
    if (xy.x < r) // left
    {
        locImg[r + xy.y][xy.x] = (XY.x >= r) ? imageLoad(inImg, XY + ivec2(-r, 0)).xyz : vec3(0.0f);
    }
    if (xy.y < r) // up
    {
        locImg[xy.y][r + xy.x] = (XY.y >= r) ? imageLoad(inImg, XY + ivec2(0, -r)).xyz : vec3(0.0f);
    }
    if (xy.x + r >= WG) // right
    {
        locImg[r + xy.y][r + xy.x + r] = (XY.x + r < HW.x) ? imageLoad(inImg, XY + ivec2(r, 0)).xyz : vec3(0.0f);
    }
    if (xy.y + r >= WG) // down
    {
        locImg[r + xy.y + r][r + xy.x] = (XY.y + r < HW.y) ? imageLoad(inImg, XY + ivec2(0, r)).xyz : vec3(0.0f);
    }
    if (xy.x < r && xy.y < r) // left-up
    {
        locImg[xy.y][xy.x] = (XY.x >= r && XY.y >= r) ? imageLoad(inImg, XY + ivec2(-r, -r)).xyz : vec3(0.0f);
    }
    if (xy.x < r && xy.y + r >= WG) // left-down
    {
        locImg[r + xy.y + r][xy.x] = (XY.x >= r && XY.y + r < HW.y) ? imageLoad(inImg, XY + ivec2(-r, r)).xyz : vec3(0.0f);
    }
    if (xy.x + r >= WG && xy.y < r) // right-up
    {
        locImg[xy.y][r + xy.x + r] = (XY.x + r < HW.x && XY.y >= r) ? imageLoad(inImg, XY + ivec2(r, -r)).xyz : vec3(0.0f);
    }
    if (xy.x + r >= WG && xy.y + r >= WG) // right-down
    {
        locImg[r + xy.y + r][r + xy.x + r] = (XY.x + r < HW.x && XY.y + r < HW.y) ? imageLoad(inImg, XY + ivec2(r, r)).xyz : vec3(0.0f);
    }
}

void horizontalPass(ivec2 xy, ivec2 XY, ivec2 HW)
{
    vec3 sum = vec3(0.0f);
    float norm = 0.0f;
    for (int x = -r; x <= r; ++x)
    {
        sum += kernel(x) * locImg[r + xy.y][r + xy.x + x];
        if (XY.x + x >= 0 && XY.x + x < HW.x)
        {
            norm += kernel(x);
        }
    }
    barrier();
    locImg[r + xy.y][r + xy.x] = sum / norm;
}

void verticalPass(ivec2 xy, ivec2 XY, ivec2 HW)
{
    vec3 sum = vec3(0.0f);
    float norm = 0.0f;
    for (int y = -r; y <= r; ++y)
    {
        sum += kernel(y) * locImg[r + xy.y + y][r + xy.x];
        if (XY.y + y >= 0 && XY.y + y < HW.y)
        {
            norm += kernel(y);
        }
    }
    barrier();
    locImg[r + xy.y][r + xy.x] = sum / norm;
}

void main()
{
    ivec2 xy = ivec2(gl_LocalInvocationID.xy);
    ivec2 XY = ivec2(gl_GlobalInvocationID.xy);
    ivec2 HW = ivec2(imageSize(inImg).xy);

    if (XY.x < HW.x && XY.y < HW.y)
    {
        loadToLoc(xy, XY, HW);

        barrier();

        horizontalPass(xy, XY, HW);

        if (xy.y < r) // no need to sync, independent passes
        {
            horizontalPass(xy + ivec2(0, -r), XY + ivec2(0, -r), HW);
        }
        if (xy.y + r >= WG)
        {
            horizontalPass(xy + ivec2(0, r), XY + ivec2(0, r), HW);
        }

        barrier();

        verticalPass(xy, XY, HW);

        barrier();

        imageStore(outImg, XY, vec4(locImg[r + xy.y][r + xy.x], 1.0));
    }
}

